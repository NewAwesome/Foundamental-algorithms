# Q xxx

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

Example 1:

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

Example 2:

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

# Solution

## Approach 1 : Bruce

思路：暴力枚举出所有可能的爬台阶组合，求和后===n 则返回 1 进行累加，求和后>n 则不合法，返回 0，不计入。

带返回值的设计思路

```
每次爬台阶一层or两层，那么base case可以随机取一个中间的状态：
1. 当前处于k层
2. 判断当前状态，当前踩的台阶数i
  （1）i>n ： 说明不合规矩，我们需要的是刚好爬到楼顶的路线；
  （2）i=n ： 说明这是我们想要的情况；
  （3）i<n ： 说明还没到楼顶，还需要继续爬
3. 下一次可以到k+1 或者k+2

*** 利用好递归函数的返回值：
  递归函数的返回值要特别当心。递归函数若带有返回值，返回值必定是通过每一个叶子调用栈返回，多数情况是满足需求返回1，进行累计求和，不满足需求则返回0，不影响最终的求和结果，只为了可以在函数中将满足需求/不满足需求的情况统一对待，因为对于递归函数来说，单独的一次调用是毫不关心其他调用栈的。（比如汉诺塔，三傻不需要知道二傻做了些什么事，只要知道自己应该做的事就可以）
```

---

## Approach 2 : Memorization

记忆化，将到达每一层台阶的总情况数存储至台阶 i 对应的数组 memo 中。

思路

```
Stuck In:
想着如何求解出每一层的情况总数f(i)然后存入数组，然后脑中模拟递归过程，发现模拟某种爬行方案仅仅能为每一个f(i)加1，并不能直接找到某个点让我去将它存到数组中

Corretify:
记忆化递归核心也还是在递归的思想上，唯一的区别在于，当我站在第i台阶，且排除end case(i>n || i==n )后，按理我应该继续处理下一步，爬一层 or 两层，但这个时候如果memo[i]>0即已经有爬到第i层的情况总数记录时，我就可以避免重复计算，仅需要返回memo[i]即可；加入memo[i]=0即没有记录的话，我们只能按部就班的递归求和计算，但递归求和之后的结果我们要先存储至memo[i]，然后再return它。

记忆化的优化思路在于避免重复计算，我们在第一次进行计算之后将其值保留下来即可实现记忆化，那么记忆化与普通的递归唯一区别就是普通递归并不关心每一次递归函数调用的返回值到底是多少，只要拿来用就行，而记忆化需要我们去关心每次递归函数调用的结果，将它保存下来。
```

---

## Approach 3 : DP

TODO: 还有几种解决方案，学习 DP 之后作为范例学习。

> https://leetcode-cn.com/explore/featured/card/recursion-i/258/memorization/1214/#5-binets
